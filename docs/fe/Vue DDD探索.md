## 前端开发面临的困难

这里我们讲到的困难并不是指技术细节实现层面上的困难，而是从整个软件开发过程中，遇到对高复杂度业务的开发困难。

比如说很难从代码中直观地看出业务逻辑，项目经历不同人手迭代导致的逻辑书写规范不一致而进一步导致的后续人员理解成本高昂。

说简单点，就是在高复杂度的业务之上，开发人员没有很强的意识去简化逻辑，将业务知识直接体现在视图代码中，我们具体从以下几个点来讲解这个问题。

### 对全局业务理解不够透彻

一个项目在开发过程中人员变动是很正常的，可能是前人离职后人接手，也可能是新增人手，新人对业务的理解往往是不够透彻的，可能一来就直接评审接着就进入开发，比如新增了一个接口需要将数据展示在页面上，该需求前因后果并不知晓，这就形成了一种“面向页面”开发模式，对业务不熟悉，自然无法合适地将新的需求代码融入整个项目体系中。

### 知识在团队传播中的丢失

复杂的业务逻辑知识在团队中是很难传播的，在人员的变动后，更是支离破碎，业务知识丢失后，开发者就会陷入“不知在哪改、不敢改、不愿改”的泥淖中，最终导致业务开发不下去，推倒重来，严重影响整个项目的进展，我们在这里能做的，就是尽量将代码写成既能运行又能展示业务逻辑知识的形态，让后续的维护者更有信心的面对“知识丢失”这一困境。

### 团队无法形成统一逻辑代码书写规范

这里我指的书写规范并不是指 eslint 之类的 style 规范，而是书写业务逻辑的位置、方式、分层、复用等，比如 A 为了将应用隔离而习惯将接口写在 UI 层直接处理数据，B 习惯将接口写在 common 模块供自己或者别人在 UI 层调用，A 习惯将 util 类工具函数直接和 api 接口混在一起写，而 B 更愿意将 util 类函数写得更通用放在 common 模块，假如新来了开发者 C ， C 看到各式各样的风格就会很疑惑，不知应该按照 A 还是 B 或者按照自己的习惯书写，随着开发人员越来越多，直接会导致了整个项目逻辑书写规范的崩溃，维护者的维护信心会大打折扣。

### 具体看看一些我们可能遇到的问题：

1. 不清晰的视图结构：

   ![image-20211010172151496](https://cdn.jsdelivr.net/gh/kilicmu/markdown-images@master//image/image-20211010172151496.png)

   **描述：**

   ​    模板 XML 视图存在很多对组件传值与服务的操作，失去清晰地视图结构性。

   **后果：**

   - 存在大量重复代码
   - 无法直观了解视图（少数组件就已经占领大面积XML）

   **优化思路：**

   - 组件通过页面级别服务的注入，减少传递行为

2.  重复判断的逻辑

   ![image-20211010172219187](https://cdn.jsdelivr.net/gh/kilicmu/markdown-images@master//image/image-20211010172219187.png)

   **描述：**

   ​    同样的逻辑在两个视图层中重复出现，假设例子中的逻辑较假设非常复杂的，各成员实现方式不一致，在后期维护将会造成许多问题。

   **后果：**

   - 违反了代码重复原则，后期需要统一修改时，涉及文件多成本大
   - 团队中各成员形成“知识不同步”,同样的功能 A B 都实现了，但是互相却不知道，并且容易出现因实现方案不同导致的结果不一致的问题

   **解决：**

   ​    试图将某个实体抽象成一个类，通过isXXX判断逻辑，明确语义且简化相关逻辑。

3. 接口字段的不可控：

   **描述：**定义字段在理想的情况下是前端主导，且前后端有共同的认知，但是不排除特殊情况下接口字段定义混乱且不直观。

   **后果：**阅读代码时，接口字段不规范，在视图层展示时，会导致误解或者难以理解的代码逻辑。

   **思路：**将接口层抽离出来，在接口返回时，逐一将字段列举出来，将不符合规范的字段进行纠正，转换成更易理解的词语，甚至在这一层中就能将很多字段内容进行转换，比如后端返回的金额为分单位*100的整数，在这一层中即将其转换为浮点数，在视图层中即可直接使用。

4. 忽略业务的整体:

   **描述：**

   ​    在一个庞大、多人协作的项目，作为其中一员很可能出现对整个系统理解不够，只知道自己负责的那几个页面，逐步恶化成“ 面向接口编程”。

   **后果：**

   ​    这对整个项目的“成长”是不利的，会导致像上述举例代码中出现的“重复性”问题。假如开发者对整个项目有全局的了解，在编码时，会考虑更多的“可拓展性”与“预判未来性”，或者在接手其他成员负责的领域也会减少很多上手成本。从业务的角度看，在需求评审的过程中，熟悉整体业务，会对其新的需求进行更深的思考，判断其对整个项目是否会有明显的“驱动”作用，而进一步考虑是否应该拒绝该需求或者提出更好的需求建议，避免成为产品经理说什么就做什么的“面向页面编程”工程师。

   **思路：**

   ​     将每一块业务划分成不同的领域，各领域下包含哪些服务，每个页面调用的并不是 API 接口，而是各自领域的服务。

### 领域驱动设计

首先提出领域的角色是需求方，每一个需求都必将会映射到某个领域，比如“搜索商品”这个动作对应着商品中心域，“用户登录”对应着用户信息&鉴权域。从产品-后端-前端对其领域的划分认知都是一致的，这是各角色对其整个项目进行合作的基础，在一起讨论问题时，都知道对方讲述的信息是处在哪个域上。

在对领域具有统一认知的情况下，需求方也会更谨慎、清晰地提出新的需求或是更改业务逻辑，各方人员对其业务的熟悉后，也能从自己负责的职能角度上表达出自己对新业务新迭代的看法或建议，而不是“机械”地根据需求文档完成自己的职责。

假设各方角色对整体业务领域不熟悉，大家对其业务的认知不统一，项目很快就会成为一个松散的结构，需求方、开发方、设计方的产出模型无法大致匹配，最后成为开发/维护代价极高的“危楼”项目。

领域驱动设计不是万能的，它只是解决了软件开发中的部分问题，也不是可适用于任何场景的，但是其核心思想是可以借鉴到软件设计与开发过程中的。

### sharp-model

code：http://dev.sankuai.com/code/repo-detail/bepfe/sharp-model/file/list

目标：解决字段不可控和接口数据未知导致的不安全访问，辅助领域驱动建模。

### 探索 Vue 在领域驱动方面的实践

code：http://dev.sankuai.com/code/repo-detail/bepfe/vue2-ddd-demo/file/list

#### 目标：

结构效果如下：

![image-20211010174007362](https://cdn.jsdelivr.net/gh/kilicmu/markdown-images@master//image/image-20211010174007362.png)

下面我们举例需要设计一个 TODO的实现需求。

#### 文件结构

![image-20211010173245102](https://cdn.jsdelivr.net/gh/kilicmu/markdown-images@master//image/image-20211010173245102.png)

#### 主要看 domain 文件夹：

每个domain分为两个部分，model为当前领域的相关模型，xxxService为此Domain主要负责的提供的相关服务（主要包含模型初始化等）。

思考需求相关的数据，并建立模型，并确立模型相关的行为，需要有一个列表，可以增删改查TODO项目。

根据需求，确定在todo domain需要新增两个Model：TaskModel 和 TaskListModel。

对于单项的Task，可以给出以下几个属性和行为：

![image-20211010174817124](https://cdn.jsdelivr.net/gh/kilicmu/markdown-images@master//image/image-20211010174817124.png)

TaskListModel可以给出以下几个属性和行为：

![image-20211010175439264](https://cdn.jsdelivr.net/gh/kilicmu/markdown-images@master//image/image-20211010175439264.png)

todoService为当前 domain 提供两个服务：

![image-20211010174611435](https://cdn.jsdelivr.net/gh/kilicmu/markdown-images@master//image/image-20211010174611435.png)

接下来只需要交给涉及此领域的顶层视图（View）注入 Model 实例即可。上述文件夹结构的 views/TODO/todo.js主要负责这个工作。

![image-20211010181604797](https://cdn.jsdelivr.net/gh/kilicmu/markdown-images@master//image/image-20211010181604797.png)

在index.vue中，顶层视图在生命周期通过调用action初始化TaskList实例：

![image-20211010180445766](https://cdn.jsdelivr.net/gh/kilicmu/markdown-images@master//image/image-20211010180445766.png)

业务组件简单的适配实例即可：

todo-list：

![image-20211010180715076](https://cdn.jsdelivr.net/gh/kilicmu/markdown-images@master//image/image-20211010180715076.png)

edit-header：

![image-20211010180843475](https://cdn.jsdelivr.net/gh/kilicmu/markdown-images@master//image/image-20211010180843475.png)

![image-20211010181709966](https://cdn.jsdelivr.net/gh/kilicmu/markdown-images@master//image/image-20211010181709966.png)

还有一些用户权鉴相关的东西，则可以放在user相关的domain中，具体做法可以参考code源码。

## 实践过程中的建议(粘的)

### 坚定信仰

领域驱动设计的初衷是将项目进行合理地结构分层，降低复杂项目的维护难度，有效地减少团队成员之间的协作成本，将业务直观地映射成代码，让开发者更关注业务整体的本身，不局限于自己的职责，共同提出更好的业务建议，只有业务真正有价值了，你写的优秀代码才能保证被传承下去。

而一个复杂项目的生命周期是非常久的，可能长达几年，维护旧代码时间肯定会比编写新需求更长，为了后期能够爽快地维护，前期多付出写时间去改善代码结构与质量，从长远的角度来看，是非常值得的。就算中途离职，留给后人的代码也能做到问心无愧，更不会留下臭名昭著的名声。

所以，这里我想说的是，做一个更理想主义的程序员，坚定自己的信念，在实行领域驱动设计的初期或许会出现各种不适，甚至会受到冷嘲热讽，挺过了这段适应期后，就能体会到自己设计的结构与代码很丝滑很优雅。

### 团队成员实时同步

团队成员之间都需要熟悉全局的领域模型，特别是当需要修改他人负责领域下的代码，更是要熟悉其领域下的细节。当团队中加入了新的成员后，先向他介绍我们项目下的领域模型，再分享我们的项目架构与分层。

在另一方面，团队协作开发最不利的因素是闭门造车，大家都不知道对方做了什么、怎么做的，很常见的问题就是重复开发，建议团队指定间隔多久进行一次讨论，大家分享自己最近做了什么或者遇到了什么困难，或许自己的困惑其他人之前也遇到过并且有很好的解决方案。大家也可以一起吐槽需求方不合理的需求，听听大家的观点，说不定还能提高自己的业务思考能力。

既然选择了领域驱动设计，那么自然地要把自己融入到整个业务、整个项目中，把自己认定为项目中不可缺少的一部分，肩负了业务前进的重任。

### 严格的 Review

因为团队中各成员的能力水平、对领域驱动设计的领悟程度不一致，在初期可能会写出不规范的代码或者结构，甚至出现错误的领域划分，在合入分支前进行严格的 Code Review 是非常有必要的，领域驱动设计是非常不抗“腐蚀”的，不能接受不规范的代码或结构，在初期的 Review 成本或许有些大，等成员之间认知统一后，后续便能愉快地一起写代码了～